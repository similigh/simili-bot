// Author: Kaviru Hapuarachchi
// GitHub: https://github.com/kavirubc
// Created: 2026-02-02
// Last Modified: 2026-02-04

// Package steps provides the response builder step.
package steps

import (
	"fmt"
	"log"
	"strings"

	"github.com/similigh/simili-bot/internal/core/pipeline"
	"github.com/similigh/simili-bot/internal/integrations/gemini"
)

// ResponseBuilder constructs the comment to post on the issue.
type ResponseBuilder struct {
	llm *gemini.LLMClient
}

// NewResponseBuilder creates a new response builder step.
func NewResponseBuilder(deps *pipeline.Dependencies) *ResponseBuilder {
	return &ResponseBuilder{
		llm: deps.LLMClient,
	}
}

// Name returns the step name.
func (s *ResponseBuilder) Name() string {
	return "response_builder"
}

// Run builds the comprehensive triage summary comment.
func (s *ResponseBuilder) Run(ctx *pipeline.Context) error {
	// Skip if it's an issue_comment and no comment has been generated by a previous step (like CommandHandler)
	if ctx.Issue.EventType == "issue_comment" && ctx.Metadata["comment"] == nil {
		return nil
	}
	log.Printf("[response_builder] Building comprehensive triage summary for issue #%d", ctx.Issue.Number)

	comment := s.buildTriageSummary(ctx)
	ctx.Metadata["comment"] = comment

	log.Printf("[response_builder] Built triage summary")
	return nil
}

// buildTriageSummary creates a comprehensive triage report.
func (s *ResponseBuilder) buildTriageSummary(ctx *pipeline.Context) string {
	var sections []string

	// Header
	sections = append(sections, "### Simili Triage Report\n")

	// Quality Assessment Section
	if qualitySection := s.buildQualitySection(ctx); qualitySection != "" {
		sections = append(sections, qualitySection)
	}

	// Classification Header
	sections = append(sections, "#### Classification")
	// Start Classification Table
	sections = append(sections, "| Category | Value |")
	sections = append(sections, "| :--- | :--- |")

	// Labels Row
	if labelsRow := s.buildLabelsRow(ctx); labelsRow != "" {
		sections = append(sections, labelsRow)
	}

	// Transfer Row
	if transferRow := s.buildTransferRow(ctx); transferRow != "" {
		sections = append(sections, transferRow)
	}

	sections = append(sections, "") // Spacing

	// Quality Improvements (Collapsible)
	if improvements := s.buildQualityImprovements(ctx); improvements != "" {
		sections = append(sections, improvements)
	}

	// Similar Issues (Collapsible)
	if similarSection := s.buildSimilarSection(ctx); similarSection != "" {
		sections = append(sections, similarSection)
	}

	// Possible Duplicate (Alert)
	if duplicateSection := s.buildDuplicateSection(ctx); duplicateSection != "" {
		sections = append(sections, duplicateSection)
	}

	// Footer
	sections = append(sections, "---\n<sub>Generated by [Simili Bot](https://github.com/similigh/simili-bot)</sub>")

	return strings.Join(sections, "\n")
}

// buildQualitySection creates the quality assessment section using GitHub Alerts.
func (s *ResponseBuilder) buildQualitySection(ctx *pipeline.Context) string {
	qualityResult, ok := ctx.Metadata["quality_result"].(*gemini.QualityResult)
	if !ok || qualityResult == nil {
		return ""
	}

	var parts []string

	// Determine alert type based on score
	alertType := "NOTE"
	if qualityResult.Score < 0.5 {
		alertType = "TIP" // Using TIP for constructive feedback on low quality
	}

	parts = append(parts, fmt.Sprintf("> [!%s]", alertType))

	assessment := capitalizeFirst(qualityResult.Assessment)
	parts = append(parts, fmt.Sprintf("> **Quality Score: %.1f/10 (%s)**", qualityResult.Score*10, assessment))

	if len(qualityResult.Issues) == 0 {
		parts = append(parts, "> The issue is well-described.")
	} else {
		parts = append(parts, "> The issue could be improved. See suggestions below.")
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// buildLabelsRow creates the labels row for the classification table.
func (s *ResponseBuilder) buildLabelsRow(ctx *pipeline.Context) string {
	if len(ctx.Result.SuggestedLabels) == 0 {
		return "| **Labels** | None |"
	}

	var badges []string
	for _, label := range ctx.Result.SuggestedLabels {
		// Heuristic: 'urgent' or 'bug' gets orange, others get black
		color := "000000" // Black
		if strings.Contains(strings.ToLower(label), "urgent") || strings.Contains(strings.ToLower(label), "high") || strings.Contains(strings.ToLower(label), "bug") {
			color = "ff7300" // Orange
		}
		// URL encode label for Shields.io
		// Shields.io escaping: underscores -> __, hyphens -> --, spaces -> %20
		encodedLabel := strings.ReplaceAll(label, "_", "__")
		encodedLabel = strings.ReplaceAll(encodedLabel, "-", "--")
		encodedLabel = strings.ReplaceAll(encodedLabel, " ", "%20")
		badges = append(badges, fmt.Sprintf("![](https://img.shields.io/badge/%s-%s)", encodedLabel, color))
	}

	return fmt.Sprintf("| **Labels** | %s |", strings.Join(badges, " "))
}

// buildTransferRow creates the transfer row for the classification table.
func (s *ResponseBuilder) buildTransferRow(ctx *pipeline.Context) string {
	routerResult, ok := ctx.Metadata["router_result"].(*gemini.RouterResult)
	if !ok || routerResult == nil || routerResult.BestMatch == nil {
		return ""
	}

	match := routerResult.BestMatch
	confidence := match.Confidence

	// Only show if medium or high confidence
	if confidence < ctx.Config.Transfer.MediumConfidence {
		return ""
	}

	targetRepo := fmt.Sprintf("%s/%s", match.Org, match.Repo)
	confidencePct := int(confidence * 100)

	sourceRepo, _ := ctx.Metadata["original_repo"].(string)

	var value string
	// Black for text, Orange for confidence badge
	confBadge := fmt.Sprintf("![](https://img.shields.io/badge/confidence-%d%%25-ff7300)", confidencePct)

	if sourceRepo != "" {
		// Actually transferred from another repo
		value = fmt.Sprintf("ðŸ”„ Transferred from **%s** %s", sourceRepo, confBadge)
	} else if targetRepo == fmt.Sprintf("%s/%s", ctx.Issue.Org, ctx.Issue.Repo) {
		// Best match is current repo
		value = fmt.Sprintf("âœ… Belongs in **%s** %s", targetRepo, confBadge)
	} else {
		// Suggestion
		value = fmt.Sprintf("Suggested: **%s** %s", targetRepo, confBadge)
	}

	return fmt.Sprintf("| **Transfer** | %s |", value)
}

// buildQualityImprovements creates the collapsible quality suggestions section.
func (s *ResponseBuilder) buildQualityImprovements(ctx *pipeline.Context) string {
	qualityResult, ok := ctx.Metadata["quality_result"].(*gemini.QualityResult)
	if !ok || qualityResult == nil {
		return ""
	}

	// Combine issues and suggestions
	var items []string
	items = append(items, qualityResult.Issues...)
	items = append(items, qualityResult.Suggestions...)

	if len(items) == 0 {
		return ""
	}

	var parts []string
	parts = append(parts, "<details>")
	parts = append(parts, "<summary>Quality Improvements</summary>")
	parts = append(parts, "")

	for _, item := range items {
		parts = append(parts, fmt.Sprintf("- %s", item))
	}

	parts = append(parts, "</details>")
	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// buildSimilarSection creates the similar issues section.
func (s *ResponseBuilder) buildSimilarSection(ctx *pipeline.Context) string {
	if len(ctx.SimilarIssues) == 0 {
		return ""
	}

	var parts []string
	parts = append(parts, "<details>")
	parts = append(parts, "<summary>Similar Threads</summary>")
	parts = append(parts, "")
	parts = append(parts, "| Similarity | Thread | Status |")
	parts = append(parts, "| :--- | :--- | :--- |")

	for _, similar := range ctx.SimilarIssues {
		var status string
		switch similar.State {
		case "closed":
			status = "Closed"
		case "open":
			status = "Open"
		default:
			status = "â€”"
		}

		// Truncate title if too long (UTF-8 safe)
		title := similar.Title
		runes := []rune(title)
		if len(runes) > 50 {
			title = string(runes[:47]) + "..."
		}

		parts = append(parts, fmt.Sprintf("| %.0f%% | [#%d %s](%s) | %s |",
			similar.Similarity*100, similar.Number, title, similar.URL, status))
	}

	parts = append(parts, "</details>")
	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// buildDuplicateSection creates the duplicate warning section.
func (s *ResponseBuilder) buildDuplicateSection(ctx *pipeline.Context) string {
	duplicateResult, ok := ctx.Metadata["duplicate_result"].(*gemini.DuplicateResult)
	if !ok || duplicateResult == nil || !duplicateResult.IsDuplicate {
		return ""
	}

	var parts []string
	confidencePct := int(duplicateResult.Confidence * 100)

	parts = append(parts, "> [!WARNING]")
	parts = append(parts, fmt.Sprintf("> **Possible Duplicate** (Confidence: %d%%)", confidencePct))
	subject := "issue"
	if ctx.Issue.EventType == "pull_request" || ctx.Issue.EventType == "pr_comment" {
		subject = "pull request"
	}
	parts = append(parts, fmt.Sprintf("> This %s might be a duplicate of #%d.", subject, duplicateResult.DuplicateOf))

	if duplicateResult.Reasoning != "" {
		parts = append(parts, fmt.Sprintf("> _Reason: %s_", duplicateResult.Reasoning))
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// capitalizeFirst capitalizes the first letter of a string.
func capitalizeFirst(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
