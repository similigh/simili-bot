// Author: Kaviru Hapuarachchi
// GitHub: https://github.com/kavirubc
// Created: 2026-02-02
// Last Modified: 2026-02-04

// Package steps provides the response builder step.
package steps

import (
	"fmt"
	"log"
	"strings"

	"github.com/similigh/simili-bot/internal/core/pipeline"
	"github.com/similigh/simili-bot/internal/integrations/gemini"
)

// ResponseBuilder constructs the comment to post on the issue.
type ResponseBuilder struct {
	llm *gemini.LLMClient
}

// NewResponseBuilder creates a new response builder step.
func NewResponseBuilder(deps *pipeline.Dependencies) *ResponseBuilder {
	return &ResponseBuilder{
		llm: deps.LLMClient,
	}
}

// Name returns the step name.
func (s *ResponseBuilder) Name() string {
	return "response_builder"
}

// Run builds the comprehensive triage summary comment.
func (s *ResponseBuilder) Run(ctx *pipeline.Context) error {
	// Skip if it's an issue_comment and no comment has been generated by a previous step (like CommandHandler)
	if ctx.Issue.EventType == "issue_comment" && ctx.Metadata["comment"] == nil {
		return nil
	}
	log.Printf("[response_builder] Building comprehensive triage summary for issue #%d", ctx.Issue.Number)

	comment := s.buildTriageSummary(ctx)
	ctx.Metadata["comment"] = comment

	log.Printf("[response_builder] Built triage summary")
	return nil
}

// buildTriageSummary creates a comprehensive triage report.
func (s *ResponseBuilder) buildTriageSummary(ctx *pipeline.Context) string {
	var sections []string

	// Header
	sections = append(sections, "## ü§ñ Simili Triage Report\n")

	// Quality Assessment Section
	if qualitySection := s.buildQualitySection(ctx); qualitySection != "" {
		sections = append(sections, qualitySection)
	}

	// Labels Section
	if labelsSection := s.buildLabelsSection(ctx); labelsSection != "" {
		sections = append(sections, labelsSection)
	}

	// Transfer Section
	if transferSection := s.buildTransferSection(ctx); transferSection != "" {
		sections = append(sections, transferSection)
	}

	// Similar Issues Section
	if similarSection := s.buildSimilarSection(ctx); similarSection != "" {
		sections = append(sections, similarSection)
	}

	// Duplicate Warning Section
	if duplicateSection := s.buildDuplicateSection(ctx); duplicateSection != "" {
		sections = append(sections, duplicateSection)
	}

	// Footer
	sections = append(sections, "---\n*AI-powered analysis by Simili-Bot*")

	return strings.Join(sections, "\n")
}

// buildQualitySection creates the quality assessment section.
func (s *ResponseBuilder) buildQualitySection(ctx *pipeline.Context) string {
	qualityResult, ok := ctx.Metadata["quality_result"].(*gemini.QualityResult)
	if !ok || qualityResult == nil {
		return ""
	}

	var parts []string
	parts = append(parts, "### Quality Assessment")

	// Score and assessment
	scoreDisplay := fmt.Sprintf("%.1f/10", qualityResult.Score*10)
	assessment := capitalizeFirst(qualityResult.Assessment)
	parts = append(parts, fmt.Sprintf("**Score:** %s (%s)", scoreDisplay, assessment))

	// Issues found
	if len(qualityResult.Issues) > 0 {
		for _, issue := range qualityResult.Issues {
			parts = append(parts, fmt.Sprintf("- ‚ö†Ô∏è %s", issue))
		}
	} else {
		parts = append(parts, "- ‚úÖ Issue is well-described")
	}

	// Suggestions
	if len(qualityResult.Suggestions) > 0 {
		parts = append(parts, "\n**Suggestions:**")
		for _, suggestion := range qualityResult.Suggestions {
			parts = append(parts, fmt.Sprintf("- %s", suggestion))
		}
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// buildLabelsSection creates the labels section.
func (s *ResponseBuilder) buildLabelsSection(ctx *pipeline.Context) string {
	if len(ctx.Result.SuggestedLabels) == 0 {
		return ""
	}

	var parts []string
	parts = append(parts, "### Suggested Labels")

	labels := make([]string, len(ctx.Result.SuggestedLabels))
	for i, label := range ctx.Result.SuggestedLabels {
		labels[i] = fmt.Sprintf("`%s`", label)
	}
	parts = append(parts, strings.Join(labels, ", "))
	parts = append(parts, "")

	return strings.Join(parts, "\n")
}

// buildTransferSection creates the transfer suggestion section.
func (s *ResponseBuilder) buildTransferSection(ctx *pipeline.Context) string {
	routerResult, ok := ctx.Metadata["router_result"].(*gemini.RouterResult)
	if !ok || routerResult == nil || routerResult.BestMatch == nil {
		return ""
	}

	match := routerResult.BestMatch
	confidence := match.Confidence

	// Only show if medium or high confidence
	if confidence < ctx.Config.Transfer.MediumConfidence {
		return ""
	}

	var parts []string
	parts = append(parts, "### Transfer Suggestion")

	targetRepo := fmt.Sprintf("%s/%s", match.Org, match.Repo)
	confidencePct := int(confidence * 100)

	if confidence >= ctx.Config.Transfer.MediumConfidence {
		sourceRepo, _ := ctx.Metadata["original_repo"].(string)
		if sourceRepo != "" {
			parts = append(parts, fmt.Sprintf("üîÑ **Transferred from %s** (%d%% confidence)", sourceRepo, confidencePct))
		} else {
			parts = append(parts, fmt.Sprintf("üîÑ **Transferring to %s** (%d%% confidence)", targetRepo, confidencePct))
		}
		parts = append(parts, fmt.Sprintf("**Reason:** %s", match.Reasoning))
		parts = append(parts, "\n*If this transfer was incorrect, comment `/undo` to move it back.*")
	} else {
		parts = append(parts, fmt.Sprintf("This issue might be better suited for **%s** (%d%% confidence)", targetRepo, confidencePct))
		parts = append(parts, fmt.Sprintf("**Reason:** %s", match.Reasoning))
		parts = append(parts, "\n*React with üëç to confirm transfer.*")
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// buildSimilarSection creates the similar issues section.
func (s *ResponseBuilder) buildSimilarSection(ctx *pipeline.Context) string {
	if len(ctx.SimilarIssues) == 0 {
		return ""
	}

	var parts []string
	parts = append(parts, "### Similar Issues")
	parts = append(parts, "| Issue | Title | Similarity | State |")
	parts = append(parts, "|-------|-------|------------|-------|")

	for _, similar := range ctx.SimilarIssues {
		status := similar.State
		if similar.State == "closed" {
			status = "closed ‚úÖ"
		}
		parts = append(parts, fmt.Sprintf("| [#%d](%s) | %s | %.0f%% | %s |",
			similar.Number, similar.URL, similar.Title, similar.Similarity*100, status))
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// buildDuplicateSection creates the duplicate warning section.
func (s *ResponseBuilder) buildDuplicateSection(ctx *pipeline.Context) string {
	duplicateResult, ok := ctx.Metadata["duplicate_result"].(*gemini.DuplicateResult)
	if !ok || duplicateResult == nil || !duplicateResult.IsDuplicate {
		return ""
	}

	var parts []string
	parts = append(parts, "### Possible Duplicate")

	confidencePct := int(duplicateResult.Confidence * 100)
	parts = append(parts, fmt.Sprintf("‚ö†Ô∏è This might be a duplicate of #%d (%d%% confidence)",
		duplicateResult.DuplicateOf, confidencePct))

	if duplicateResult.Reasoning != "" {
		parts = append(parts, fmt.Sprintf("**Reason:** %s", duplicateResult.Reasoning))
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// capitalizeFirst capitalizes the first letter of a string.
func capitalizeFirst(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}
